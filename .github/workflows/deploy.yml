name: Deploy to EC2 with GitHub Actions

on:
  push:
    branches: [develop]
  pull_request:
    branches: [develop]

jobs:
  build-and-deploy:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      # 1) 코드 체크아웃
      - name: Checkout
        uses: actions/checkout@v3

      # 2) JDK 21 설치 (빌드용)
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'corretto'

      # 3) Gradle 캐시
      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      # 4) gradlew 실행권한
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 5) 코드 스타일 체크 (Spotless)
      - name: Check code style with Spotless
        run: ./gradlew spotlessCheck

      # 6) 빌드 (테스트 제외)
      - name: Build with Gradle
        run: ./gradlew build -x test

      # 7) 빌드 산출물(SNAPSHOT) 파일명 추출 (단일 파일 보장)
      - name: Find and export JAR file name
        id: find_jar
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t FILES < <(find build/libs -maxdepth 1 -type f -name "*-SNAPSHOT.jar" | sort)
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "::error::No SNAPSHOT JAR file found in build/libs/"
            exit 1
          fi
          JAR_FILE_PATH="${FILES[0]}"
          JAR_FILE_NAME="$(basename "$JAR_FILE_PATH")"
          echo "Found JAR file: $JAR_FILE_NAME"
          echo "JAR_NAME=$JAR_FILE_NAME" >> "$GITHUB_OUTPUT"

      # (디버그) 로컬 빌드 산출물 확인
      - name: Debug - list local build/libs
        run: ls -al build/libs

      # 8) 원격 타겟 디렉터리 보장
      - name: Ensure target dir on EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_PEM_KEY }}
          script: |
            set -e
            mkdir -p /home/${USER}/Team15_BE

      # 9) 정확히 단일 파일만 전송 + 경로 납작화(strip_components: 2)
      - name: Copy JAR to EC2 (flatten path)
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_PEM_KEY }}
          source: "build/libs/${{ steps.find_jar.outputs.JAR_NAME }}"
          target: "/home/${{ secrets.EC2_USER }}/Team15_BE"
          overwrite: true
          strip_components: 2

      # 10) EC2에서 파일 존재 확인(루트에 존재해야 함)
      - name: Verify file transfer on EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_PEM_KEY }}
          script: |
            set -euo pipefail
            APP_DIR="/home/${USER}/Team15_BE"
            echo "--- Full listing of ${APP_DIR} ---"
            ls -al "${APP_DIR}"
            echo "--- Verifying specific file ---"
            ls -l "${APP_DIR}/${{ steps.find_jar.outputs.JAR_NAME }}"

      # 11) 배포 & 실행 (심볼릭 링크 + 안전한 중지)
      - name: Deploy and Run on EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_PEM_KEY }}
          script: |
            set -Eeuo pipefail

            APP_DIR="/home/${USER}/Team15_BE"
            JAR_NAME="${{ steps.find_jar.outputs.JAR_NAME }}"
            APP_JAR="app.jar"                           # 고정 실행명
            LOG_DIR="${APP_DIR}/logs"
            START_PATTERN="java -jar ${APP_JAR}"

            cd "${APP_DIR}" || { echo "Failed to change directory to ${APP_DIR}"; exit 1; }

            # Java 존재 여부 확인
            if ! command -v java >/dev/null 2>&1; then
              echo "ERROR: 'java' command not found on EC2. Install JDK/JRE first."
              exit 1
            fi

            # 최신 JAR를 app.jar 심볼릭 링크로 연결(원본은 그대로 유지)
            if [ ! -f "${JAR_NAME}" ]; then
              echo "ERROR: JAR not found: ${JAR_NAME}"
              ls -al .
              exit 1
            fi
            ln -sfn "${JAR_NAME}" "${APP_JAR}"
            echo "Linked ${JAR_NAME} -> ${APP_JAR}"

            # 기존 프로세스 정상 종료(SIGTERM), 실패코드는 무시
            echo "Checking for running Java application..."
            if pgrep -f "${START_PATTERN}" >/dev/null 2>&1; then
              echo "Running application found. Attempting to stop it (SIGTERM)..."
              pkill -TERM -f "${START_PATTERN}" || true

              # 최대 30초 대기, 남아있으면 SIGKILL
              for i in {1..30}; do
                if pgrep -f "${START_PATTERN}" >/dev/null 2>&1; then
                  sleep 1
                else
                  echo "Application stopped gracefully."
                  break
                fi
                if [ "$i" -eq 30 ]; then
                  echo "Process still alive after 30s. Sending SIGKILL..."
                  pkill -KILL -f "${START_PATTERN}" || true
                  sleep 2
                fi
              done
            else
              echo "No running application found. Skipping stop."
            fi

            # 로그 디렉터리 준비
            mkdir -p "${LOG_DIR}"
            LOG_FILE_NAME="$(date +'%Y-%m-%d_%H-%M-%S').log"
            LOG_FILE_PATH="${LOG_DIR}/${LOG_FILE_NAME}"

            # 기동
            echo "Starting new application (${APP_JAR})... Logging to ${LOG_FILE_PATH}"
            JAVA_OPTS="--spring.datasource.url=jdbc:mysql://${{ secrets.EC2_HOST }}:3306/${{ secrets.DB_NAME }}?useSSL=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8 \
                       --spring.datasource.username=${{ secrets.DB_USER }} \
                       --spring.datasource.password=${{ secrets.DB_PASSWORD }} \
                       --jwt.secret=${{ secrets.JWT_SECRET }}"
            nohup java -Dspring.profiles.active=dev -jar "${APP_JAR}" $JAVA_OPTS > "${LOG_FILE_PATH}" 2>&1 &

            # 기동 확인
            echo "Verifying application startup..."
            sleep 15
            if pgrep -f "${START_PATTERN}" >/dev/null 2>&1; then
              echo "Application started successfully."
              exit 0
            else
              echo "ERROR: Application failed to start. Last 120 log lines:"
              tail -n 120 "${LOG_FILE_PATH}" || true
              exit 1
            fi

